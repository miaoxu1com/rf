class  myclass:
  def savafile(self,a):
    self.a = a
    self.b = 'b'
  def findfile(self):
    print(self.a,self.b)
  def deletefile(self,c)
    print(c)
    print(self.c)#打印出错因为注入到类中的实参是没有在init中初始化所以c不是类的属性,只是一个方法的局部变量
testA = myclass('a')
#这里实例testA的属性不是类的属性，所以一下属性只有testA有
testA.name = 'wusu'
testA.sex = 'man'
print(testA.name,testA.sex)

testB = myclass('b')
print(testB.name,testB.sex)#打印报错name,sex属于实例testA的，类没有这些属性所以报错
testB.findfile() #报错因为self.a,self.b是在savafile方法中定义的,没有先调用savafile方法self.a，self.b就不会被加载到内存中
所以要想testB.findfile() ，就要先执行testB.savafile()
savefile相当于了init方法的作用只是init是在初始化实例的时候就被自动执行了，属性已经被提前加载到内存中了所以后面所有的方法才可以调用在init中定义的属性，也就是属性被全局化了

所以类可以没有init  但是要用类的属性时一定要使用init 方便了很多，初始化都可以在init中添加
定义类方法中每个方法中都要有一个self这个就是在每个方法中都注入了一个类的实例，而且有没有init都有self,在实例化类的时候就会有一个self被加载到内存中并指向这个类,打印self可以看到显示的
是实例的十六进制地址，实例化几次就会打印几次地址

类在定义的时候是()里不是写的参数，定义时注入代表的是继承类,实例化是调用是参数的注入
读和写都是对文件来说的,wb写二进制文件首先是会在内存中开辟二进制缓存空间然后把读取到的数据流写到这个缓存空间中最后写入到磁盘

自己模拟类的继承来探索继承关系A有init函数B继承A，B没有init函数在实例化B时会自动执行A的init
class A:
  def __init__(self):
  print('A')
class B(A):
  def man(self):
    print('man')
自己模拟类的继承来探索继承关系A有init函数B继承A，B有init函数在实例化B时会执行B的init,这时要想调用A的init就要在B的init中手动初始化A的init方法
class A:
  def __init__(self):
  print('A')
class B(A):
  def __init__(self):
    print('B')
 所有我们在写多线程时要在子类的init中手动执行 threading.Thread.__init__


    python生成组件的win32 COM接口文件调用对应的接口与程序进行交互
1.安装pywin32
   安装pywin32 包含了win32api 和win32com 等几个非常强大的模块，安装完成后，会在python目录下的Lib/site-packages/下生成win32 win32com 和win32comext三个文件夹
里边都有demons
2.生成com组件对应的.py文件
双击/win32com/client/目录中的make.py会弹出机器中所有的com组件
双击我们需要的类型库，会在/win32com/gent_py/目录下生成该组件的py文件 找不到使用everything搜索
3.研究生成的py接口文件
打开py文件会显示一些基本信息，以及接口函数，一些重要的参数（CLSID）

可以通过for 循环实例化  放在一个数组中 然后这个这个数组接口就相当于  [{},{}]这样的结构了

